<html><head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link class="favicon" rel="icon" href="../../favicon.ico">
  <link class="main_style" rel="stylesheet" href="../../main_style.css">
  <link class="hljs_style" rel="stylesheet" href="../../hljs_style.css">
  <script class="main_script" type="text/javascript" src="../../main.js"></script>
  <title>Underdisc</title>
</head>

<body>
  <div class="main_grid">
    <div class="sidebar">
      <div class="header">
        <div class="arrow_container">
          <svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" viewBox="0 0 26.5 26.5">
            <path fill="#fff" paint-order="stroke markers fill" d="M13.2 0A13.2 13.2 0 000 13.2a13.2 13.2 0 0013.2 13.3 13.2 13.2 0 0013.3-13.3A13.2 13.2 0 0013.2 0zm-2.6 5.3h5.3v9.3h5.3l-8 7.9-8-8h5.4z"/>
          </svg>
        </div>
        <div class="header_text">Underdisc</div>
        <div></div>
      </div>
      <div class="links">
        <a class="sidebar_element index_link" href="../../index.html">Home</a>
        <a class="sidebar_element blog_link" href="../../blog/index.html">Blog</a>
        <a class="sidebar_element projects_link" href="../../projects/index.html">Projects</a>
      </div>
    </div>
    <div class="content_container"><h1>Serialization With Valkor</h1>
<p>After finishing gizmos, the next major task was serialization. There&apos;s a few popular options for this. One can use JSON as the file format and use something like <a href="https://github.com/nlohmann/json">nlohmann/jsoncpp</a> for the cpp side of it. <a href="https://yaml.org/">YAML</a> is also an option. There are probably plenty of small options out there as well. As has been typical for me, I decided to not use any of those options and instead made my own serialization language that can be read using a small cpp library I cooked up. This language is called Valkor.</p>
<p>Similar to gizmos, my reason for making this is a concoction of control and curiousity. When it comes to control, making my own serialization language gives me the opportunity to make any decisions I want. I can make it look how I want and I can make the processing work how I want. It turns out this is both a blessing and a curse. That will become apparent throughout the post. Curiosity takes the role of main ingredient in this mixture, though. In college, one of the last classes I took was on compilers and interpreters. I learned about everything one would need to make a serialization language from the beginning of that class. It would feel strange not to take a crack at making my own language after having a class that directly discussed the topic and it would really become a missed opportunity. With that thought in mind, I was curious about what hills there were to climb while making a language. Albeit a simple language, but there must be hills nonetheless. It turns out there are many and a lot of it comes down to the &quot;freedom&quot; that comes with making it.</p>
<p>Like my last post, this one will also be split up into a few sections. First, I&apos;ll cover the inception of the language and how I got started. After that, I&apos;ll give an overview of what using the language&apos;s cpp interface looks like for performing data serialization. Then, last but not least, I&apos;ll talk about the deserialization process. Along the entire way, I&apos;ll be discussing the problems I encountered while developing. The implementation for the language can be found in Varkor&apos;s <a href="https://github.com/Underdisc/Varkor/tree/master/src/vlk">vlk directory</a>. Here&apos;s <a href="https://github.com/Underdisc/Varkor/tree/9e9ac4eb1b4d9b3a50ab36e2eb2da01042c2c990/src/vlk">another link</a> for the repo&apos;s top commit when this was posted since things may change in the future. Without further ado, let&apos;s dive in.</p>
<h1>Shitty Inception</h1>
<p>The first step involved in writing Valkor was, well, writing Valkor. Before implementing anything, I started writing down an example of what Valkor might look like after getting to the point where I could reliable save things to file and load them. Unfortunately, I couldn&apos;t find a copy of the first draft I made. So, here&apos;s my best rendition of what my ridiculously naive version of Valkor looked like.</p>
<div class="code_box"><pre><code>// A key Value pair.
Key: Value

// A key with an array of key value pairs
&gt; Key
  Key: Value
  Key: Value

// a key with an array of values.
&gt; Key
  Value
  Value
  Value

// A key with a multidimensional array of values.
&gt; &gt; Key
  &gt; Value
    Value
    Value
  &gt; Value
    Value
    Value
</code></pre></div>
<p>This dumpster fire is nothing like what Valkor ended up being except for the fact that there are keys, values, and colons. I don&apos;t think the above snippet really does justice (or lack thereof) to just how weird the first version was. I remember looking at it and thinking, &quot;There&apos;s no way I can get this shit to work.&quot;, but I feel like the snippet above represents something actually possible. The devil is in the details, though. Let me explain.</p>
<p>What&apos;s a problem with this snippet? Here&apos;s one. Look at the key that&apos;s an array of values. What happens to the first key after that array?</p>
<div class="code_box"><pre><code>&gt; Key
  Value
  Value
  Value
Key: Value
</code></pre></div>
<p>How does one distinguish the key on the last line as a key? It&apos;s important to note that one of my goals for the language was to not have forced formatting standards: no forced indentation, no forced new lines, no adderall, etc. With that in mind, let&apos;s rewrite this.</p>
<div class="code_box"><pre><code>&gt; Key Value Value Value Key: Value
</code></pre></div>
<p>From the perspective of a parser, the last key could be mistaken for a value. This forces us to answer a question. <em>What makes a key a key and a value a value?</em> We could address this by requiring keys to end with colons. So, a key would look something like <code>anExampleKey:</code>. Let&apos;s rewrite the example with that in mind.</p>
<div class="code_box"><pre><code>&gt; Key:
  Value
  Value
  Value
Key: Value
</code></pre></div>
<p>The only difference here is that the first key ends with a colon. But what about the arrow that signifies an array? Shouldn&apos;t that also mean that the string is treated as a key? One could add that rule, but what happens when we have multidimensional arrays?</p>
<div class="code_box"><pre><code>&gt; &gt; Key
  &gt; Value
    Value
  &gt; Value
    Value
</code></pre></div>
<p>Because values and keys can come after array arrows, we can&apos;t bake that into the definition of a key. The fact that two arrows happen in succession makes things even more tricky. To make matters worse, what if we have an array of key value pairs instead of just values? I could have attempted to address these problems during the parsing phase, but no attempt was made since I didn&apos;t go forward with this syntax.</p>
<p>My point here is to show that freedom is nice to have, but it doesn&apos;t mean everything that comes out of your ass will work out. That fact made finding a usable syntax very difficult and was one of the larger challenges I faced while developing the language. It&apos;s nothing like a cs class where you are given a language and expected to process it. I don&apos;t want to go into more details about this initial prototype because it is not what Valkor ended up being, but I did want to show the origins of the language because it&apos;s part of the story.</p>
<h1>The Writer</h1>
<p>After playing around with some initial prototypes of what Valkor files (.vlk) might look like, I didn&apos;t feel ready to start making something that deserialized a vlk file. It didn&apos;t make sense to do so when I still didn&apos;t know exactly what the syntax would look like. To get past that phase, I wrote something called the Writer to shift my focus entirely to serialization. The idea was to find a syntax that could be deserialized by first serializing it programmatically. It would be easier to deal with the process of reading after knowing exactly what to expect from a vlk file.</p>
<p>I didn&apos;t have much intent to read the data I was spitting out just yet. I wanted to find something human-readable that I could print before trying to deserialize it. I knew the Writer would be thrown out upon moving to the next step. Since it wouldn&apos;t need to scale, I ignored the Writer&apos;s issues and focused entirely on getting something working. Ignoring implementation details, the snippet below shows what using the Writer looked like and the comment below shows the output of the snippet. I&apos;ll be using this format from now on for showing the output of a snippet.</p>
<div class="code_box"><pre><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriterExample</span><span class="hljs-params">()</span>
</span>{
  writer &lt;&lt; Request::Array &lt;&lt; <span class="hljs-string">&quot;Array1&quot;</span>;
  writer &lt;&lt; Request::Value &lt;&lt; <span class="hljs-string">&quot;Float&quot;</span> &lt;&lt; <span class="hljs-number">5.5f</span>;
  writer &lt;&lt; Request::Array &lt;&lt; <span class="hljs-string">&quot;Array2&quot;</span>;
  writer &lt;&lt; Request::ValueArray &lt;&lt; <span class="hljs-string">&quot;Strings&quot;</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)
  {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> ss;
    ss &lt;&lt; <span class="hljs-string">&quot;string &quot;</span> &lt;&lt; i;
    writer &lt;&lt; ss.str().c_str();
  }
  writer &lt;&lt; Request::EndValueArray &lt;&lt; Request::EndArray &lt;&lt; Request::EndArray;

  <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span>&amp; content = writer.GetCompleteBuffer();
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; content.str() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">/*****
Array1: {
  Float: 5.5
  Array2: {
    Strings: [
      &quot;string 0&quot;
      &quot;string 1&quot;
      &quot;string 2&quot;
      &quot;string 3&quot;
      &quot;string 4&quot;
    ]
  }
}
*****/</span>
</code></pre></div>
<p>It was cumbersome, but it got the job done. I finally had some output to start thinking about deserilaization with. It also allowed me to experiment with a serialization interface to avoid potential potholes in the future. This god-awful line is a perfect example of a pothole that was filled in upon moving forward: <code>writer &lt;&lt; Request::EndValueArray &lt;&lt; Request::EndArray &lt;&lt; Request::EndArray;</code>.</p>
<p>The output created using the Writer was a major leap from the initial versions of Valkor that I was toying with, too. Keys ended up receiving an ending colon to distinguish them from values. Instead of using <code>&gt;</code> for arrays, <code>[]</code> is used. There is a distinction between value arrrays <code>[]</code> and key value pair arrays <code>{}</code>, which I just call pair arrays. These changes brought Valkor to a stage where deserializing it seemed much more feasible and thus I was ready to address the most exciting part: loading.</p>
<h1>Serialization Overview</h1>
<p>Unfortunately, discussing the next chronological step wouldn&apos;t flow nicely from the previous section about the Writer, because it would force the post to go back and forth between serialization and deserialization. Thus, before talking about deserialization, I want to go over the interface that Valkor ended up with for serialization. Just be aware that this is not the order things were done in.</p>
<p>The primary interface for serializing data into Valkor text is the Vlk::Value. New Values can be encapsulated within others, they can be saved to file, and loaded from file. Let&apos;s start digging into what that looks like. To start serializing data, there must always be a root Value. This Value will hold everything we care about.</p>
<div class="code_box"><pre><code>Vlk::Value rootVal;
rootVal.Write(<span class="hljs-string">&quot;filename.vlk&quot;</span>);
<span class="hljs-comment">/*****
{}
*****/</span>
</code></pre></div>
<p>If you&apos;re a user of the mighty JSON, this should look very familiar to you. The first thing to know about Vlk::Value is that everything is a Vlk::Value. They are a bit like shapeshifters, though. In particular, they can take three different forms. The most useful form they can take is a PairArray.</p>
<p>In the snippet above, rootVal is an unused (uninitialized) Value. When a Value is uninitialized like this, it becomes an empty PairArrary <code>{}</code> when written to file. Instead of just keeping it empty, we can fill up that PairArray with Pairs. Pairs are no different than Values except for the fact that they have an extra key string, making them key value pairs. Let&apos;s add some empty PairArrays to our root Value.</p>
<div class="code_box"><pre><code>Vlk::Value rootVal;
rootVal(<span class="hljs-string">&quot;SubVal1&quot;</span>);
rootVal(<span class="hljs-string">&quot;SubVal2&quot;</span>);
rootVal.Write(<span class="hljs-string">&quot;filename.vlk&quot;</span>);
<span class="hljs-comment">/*****
{
  :SubVal1: {}
  :SubVal2: {}
}
*****/</span>
</code></pre></div>
<p>This <code>rootVal(&quot;SubVal&quot;);</code> syntax creates the new Value within the PairArray. We can keep track of that new Value because the Value&apos;s <code>()</code> operator returns it. With access to that Value, we can start adding elements to our sub PairArrays like so: <em>For snippets after this one, you can assume that the <code>Vlk::Value rootVal;</code> and <code>rootVal.Write(&quot;filename.vlk&quot;);</code> lines are at the beginning and end of the serialization code, respectively.</em></p>
<div class="code_box"><pre><code>Vlk::Value rootVal;
Vlk::Value&amp; subVal = rootVal(<span class="hljs-string">&quot;SubVal&quot;</span>);
subVal(<span class="hljs-string">&quot;SubSubVal&quot;</span>);
rootVal.Write(<span class="hljs-string">&quot;filename.vlk&quot;</span>);
<span class="hljs-comment">/******
{
  :SubVal: {
    :SubSubVal: {}
  }
}
******/</span>
</code></pre></div>
<p>Value would be useless if it could only be a PairArray. Anything added would boil down to empty PairArrays. That&apos;s why Value can take other forms though. The next most important form it takes that we should talk about is a TrueValue.</p>
<p>TrueValues are as true a Value that any Value can be. They are used to store a number or string. In general, they are used for storing literals. We can make a Value take this form by assigning to it.</p>
<div class="code_box"><pre><code>Vlk::Value&amp; trueVal = rootVal(trueVal);
trueVal = <span class="hljs-string">&quot;A true Value within Valkor.&quot;</span>
<span class="hljs-comment">/******
{
  :TrueVal: &quot;A TrueValue within Valkor.&quot;
}
******/</span>
</code></pre></div>
<p>I kept it separate for clarity, but in case it wasn&apos;t obvious, we don&apos;t need to keep a reference to the new Value before assigning to it. We can instead just assign to it directly on the same line where the new Value is added to a PairArray. Imo, this offers some pretty nice-looking code.</p>
<div class="code_box"><pre><code>rootVal(<span class="hljs-string">&quot;Integer&quot;</span>) = <span class="hljs-number">10</span>;
rootVal(<span class="hljs-string">&quot;Float&quot;</span>) = <span class="hljs-number">1.0f</span>;
rootVal(<span class="hljs-string">&quot;String&quot;</span>) = <span class="hljs-string">&quot;Hello String&quot;</span>
<span class="hljs-comment">/******
{
  :Integer: 10
  :Float: 1.0
  :String: &quot;Hello String&quot;
}
******/</span>
</code></pre></div>
<p>Though important, and really the center of Valkor&apos;s existence, there is not so much to talk about with TrueValues, and that&apos;s on purpose. They should be simple, since that&apos;s the thing we care about most: real data.</p>
<p>Before discussing the last type of Value, I want to address one core detail to make sure it wasn&apos;t missed: <em>How is the initialization of a PairArray Value different from the initialization of a TrueValue Value?</em> The answer lies in the usage of the Value. Take a look at the following snippet:</p>
<div class="code_box"><pre><code>Vlk::Value&amp; willBecomePairArry = root(<span class="hljs-string">&quot;PairArray&quot;</span>);
Vlk::Value&amp; willBecomeTrueValue = root(<span class="hljs-string">&quot;TrueValue&quot;</span>);
willBecomePairArray(<span class="hljs-string">&quot;NewElement&quot;</span>);
willBecomeTrueValue = <span class="hljs-string">&quot;NewValue&quot;</span>;
<span class="hljs-comment">/*****
{
  :PairArray: {
    :NewElement: {}
  }
  :TrueValue: &quot;NewValue&quot;
}
*****/</span>
</code></pre></div>
<p>The <code>root(&quot;PairArray&quot;)</code> and <code>root(&quot;TrueValue&quot;)</code> statements only create new Values. They have yet to be initialized. The way they are initialized depends on how they are used for the first time. When we say <code>willBecomePairArray(&quot;NewValue&quot;)</code> the Value becomes a PairArray because we are using it like one by adding a new Value to it. <code>willBecomeTrueValue = &quot;NewValue&quot;</code> initializes that Value&apos;s type as TrueValue because we assigned a value to it. Essentially, the operator used on a Value defines its type. Once you use one operator on a Value, using another is an error.</p>
<div class="code_box"><pre><code>Vlk::Value&amp; crashValue = root(<span class="hljs-string">&quot;PairArray&quot;</span>);
crashValue(<span class="hljs-string">&quot;PairArray&quot;</span>);
crashValue = <span class="hljs-string">&quot;Crash&quot;</span>;
</code></pre></div>
<p>After <code>crashValue</code> is used like a PairArray on the second line, it is then used like a TrueValue on the third line and this will result in a crash at runtime. Once a Value takes a form, it may never switch forms.</p>
<p>With that covered, we can finally talk about the last form of a Value, the ValueArray. It is used to store an array of Values with no key strings attached.</p>
<div class="code_box"><pre><code>Vlk::Value&amp; integerArray = root(<span class="hljs-string">&quot;IntegerArray&quot;</span>);
integerArray[{<span class="hljs-number">3</span>}];
integerArray[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;
integerArray[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;
integerArray[<span class="hljs-number">2</span>] = <span class="hljs-number">12</span>;
<span class="hljs-comment">/*****
{
  :IntegerArray: [10, 11, 12]
}
*****/</span>
</code></pre></div>
<p>Just like a Value&apos;s type becomes PairArray after using the <code>()</code> operator or TrueValue after using the <code>=</code> operator, it becomes ValueArray after using the <code>[]</code> operator. In particular, an initializer list must be used as an argument to the first use of the <code>[]</code> operator to specify the ValueArray&apos;s size, e.g. <code>[{sizeOfArray}]</code>. Not specifying the size in this fashion will result in a crash because the Value still won&apos;t have a type.</p>
<p>Single dimensional arrays are nice, but it wouldn&apos;t be complete without multiple dimensions. Multidimensional arrays can be created by adding arguments to the initializer list like so. In this instance, the array contains two arrays that each contain two arrays with three elements:</p>
<div class="code_box"><pre><code>Vlk::Pair&amp; intArrays = root(<span class="hljs-string">&quot;intArrays&quot;</span>)[{<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i)
{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; ++j)
  {
    intArrays[i][j][<span class="hljs-number">0</span>] = i + j;
    intArrays[i][j][<span class="hljs-number">1</span>] = i + j + <span class="hljs-number">1</span>;
    intArrays[i][j][<span class="hljs-number">2</span>] = i + j + <span class="hljs-number">2</span>;
  }
}
<span class="hljs-comment">/*****
{
  :intArrays: [
    [
      [0, 1, 2],
      [1, 2, 3],
    ],
    [
      [1, 2, 3],
      [2, 3, 4],
    ],
  ]
}
*****/</span>
</code></pre></div>
<p>This leaves only one thing left to be desired: what if we want a multidimensional array where the subarrays have different sizes? I am happy to say that it&apos;s possible. To do it, we split up the initializer list specifying the length of each dimension into smaller initializer lists. In the example below, the first subarray is initialized with a length of 2 and the second subarray is initialized with a length of 3.</p>
<div class="code_box"><pre><code>Vlk::Pair&amp; intArrays = root(<span class="hljs-string">&quot;intArrays&quot;</span>)[{<span class="hljs-number">2</span>}];
intArrays[<span class="hljs-number">0</span>][{<span class="hljs-number">2</span>}];
intArrays[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
intArrays[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;
intArrays[<span class="hljs-number">1</span>][{<span class="hljs-number">3</span>}];
intArrays[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;
intArrays[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;
intArrays[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;
<span class="hljs-comment">/*****
{
  :intArrays: [[1, 2], [3, 4, 5]]
}
*****/</span>
</code></pre></div>
<p>That&apos;s all there is to serialization with Valkor. Overall, I am pleased with the interface. It gets the job done and it does so without being obtuse or overly cumbersome to use. Just getting those qualities was a major challenge, because along the way I encountered many problems and the solution to the largest of those issues and the crux of many others only showed up while writing this post.</p>
<h1>Serialization Problems</h1>
<p>Early on in the development of Valkor, my thoughts about what the center of the language was were not clear. At the time, serialization and deserialization work was happening more or less in tandem and the first versions of the grammar were being iterated on (more on that in the next section). During this time, Values were not on my mind as the center of everything in Valkor. It was Pairs. Everything was a Pair to me, not a Value. I don&apos;t know exactly why this was the case, but it must have had to with the fact that Pairs were extremely important not for storing data, but for finding specific data. This is the purpose of Pairs. Without it, we would just be putting numbers in a file without any other context. Because some sort of label is a core requirement for something like Valkor, it&apos;s not all too surprising that I gave it so much weight.</p>
<p>When I had this mindset, I made the decision to let the root Value be a Pair. That way the root Value could also have a key string. This would allow someone to bake a string into the root key. The benefit I saw is that the name of the serialized thing or any other fitting string could be stored in the key. This is no longer working code, but as an example, here&apos;s what I mean. I am using <code>Vlk::Pair</code> instead of <code>Vlk::Value</code> because that&apos;s how it used to be.</p>
<div class="code_box"><pre><code><span class="hljs-function">Vlk::Pair <span class="hljs-title">rootPair</span><span class="hljs-params">(<span class="hljs-string">&quot;rootKey&quot;</span>)</span></span>;
<span class="hljs-comment">/*****
:RootKey: {
}
*****/</span>
</code></pre></div>
<p>Doing this seemed harmless. It wasn&apos;t at all difficult to add, essentially effortless. It lined up with the thoughts I was having about the library. It just looked like an easy win. However, because specifying this key was only possible through Pair&apos;s constructor, it was an indication of the significant mistake that giving the limelight to Pair was. In the current implemenation, Vlk::Pair inherits from Vlk::Value, but a while back, it looked like this:</p>
<div class="code_box"><pre><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span>
{</span>
  <span class="hljs-comment">//...</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> mKey;
  Value mValue;
};
</code></pre></div>
<p>Just like Value, Pair made use of the same operators discussed in the previous section in largely the same way and that resulted in some large swaths of unnecessary and repitious code. Pair was forced to contain a bunch of functions that would just call the equivalent Value function. The snippet below is one of many examples of this atrocious pattern.</p>
<div class="code_box"><pre><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Value</span>
{</span>
  <span class="hljs-comment">//...</span>
  <span class="hljs-function">Pair&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* key)</span></span>;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span>
{</span>
  <span class="hljs-comment">//...</span>
  <span class="hljs-function">Pair&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* key)</span>
  </span>{
    <span class="hljs-keyword">return</span> mValue(key);
  }
};
</code></pre></div>
<p>I didn&apos;t like this code and knew it was a problem, but I wasn&apos;t entirely sure how to mend it. I debated merging Pair and Value, but I never did that because I knew the Values within a ValueArray would not need key strings. It was this multitude of single line functions that made me realize Pair should inherit from Value. That way Pair could do everything that Value could do, ValueArrays would not contain unnecessary memory for key strings, and Pairs could still have keys by having another member.</p>
<div class="code_box"><pre><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span>:</span> <span class="hljs-keyword">public</span> Value
{
  <span class="hljs-comment">//...</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> mKey;
};
</code></pre></div>
<p>It was a step in the right direction, but I was still a bit oblivious to the fact that Value would be better than Pair as Valkor&apos;s driving interface. It was only while writing this post and attempting to justify the fact that the root Value could be a Pair did I realize why I had not fully converted. Like I said and provided an example of just a bit ago, giving the root Value a key was a matter of passing a string into the Pair&apos;s constructor. This was the only functionality that Pair provided that Value did not. Because of that, all of my serialization code was still using Vlk::Pair instead of Vlk::Value. Well, the very last thing I did to Valkor was remove this feature which I initially thought was an &quot;easy win&quot;. I finally felt at peace once the tension between Pair and Value had finally been resolved.</p>
<p>At the beginning of the post, I said that a lot of problems can arise from having the freedom of doing what you want and thinking what you want. This is the biggest example I have of that from Valkor&apos;s development. From the freedumb of thinking that Pairs were the center, to the freedumb of adding an easy and seemingly harmless feature. It&apos;s great to learn from mistakes like this, but it shows that when there is nothing acting as a guide, it&apos;s shockingly easy to lead oneself astray.</p>
<h1>Tokenization, Parsing, and Syntax</h1>
<p>With serialization covered, we can now start to discuss deserialization. Deserialization became the major focus directly after I finished the Writer because there was finally something that needed to be deserialized. In the beginning, my goal was to take the output from the Writer and figure out how to read it. Step one in that process is tokenization. Tokenization involves taking an array of characters and translating it into an array of Tokens. It will make sure that every group of characters in the text is a valid token. As an example, here is a Valkor snippet and its resulting tokens. The type of token is on the left and the string it represents is on the right. This example in particular makes use of every token type.</p>
<div class="code_box"><pre><code>{
  :IntegerArray: [10, 11]
}

   OpenBrace: &quot;{&quot;
  Whitespace: &quot;\n  &quot;
         Key: &quot;:IntergerArray:&quot;
  Whitespace: &quot; &quot;
 OpenBracket: &quot;[&quot;
   TrueValue: &quot;10&quot;
       Comma: &quot;,&quot;
  Whitespace: &quot; &quot;
   TrueValue: &quot;11&quot;
CloseBracket: &quot;]&quot;
  Whitespace: &quot;\n&quot;
  CloseBrace: &quot;}&quot;
</code></pre></div>
<p>Once a piece of text is represented as a list of tokens, we move on to parsing. Parsing will garauntee that the order of tokens is correct. More simply, tokenization verifies proper spelling and parsing verifies proper grammar. In fact, the set of rules representing the parsing phase is called a grammar because it&apos;s exactly that. Valkor&apos;s grammar began very simple and was slowly fleshed out. Here&apos;s the first version of the Valkor grammar that was used to parse the Writer&apos;s output.</p>
<div class="code_box"><pre><code>Pair = &lt;Key&gt; &lt;Colon&gt; (&lt;TrueValue&gt; | ValueArray | PairArray)
PairArray = &lt;OpenBrace&gt; Pair* &lt;CloseBrace&gt;
ValueArray = &lt;OpenBracket&gt; (&lt;TrueValue&gt;* | ValueArray*) &lt;OpenBracket&gt;
</code></pre></div>
<p>Reading into what this means is not exactly straightfoward and I hope these posts can be followed by more people than just programmers, so here&apos;s an explanation. Every line represents a rule. The above grammar has three rules: <code>Pair</code>, <code>PairArray</code>, and <code>ValueArray</code>. Every time there is something of the form <code>&lt;TokenType&gt;</code>, it represents one of the token types from the tokenization phase. If there are no angle brackets, that represents another grammar rule. With that knowledge, let&apos;s break down the fist rule in the original Valkor grammar:</p>
<div class="code_box"><pre><code>Pair = &lt;Key&gt; &lt;Colon&gt; (&lt;Value&gt; | ValueArray | PairArray)
</code></pre></div>
<p>This is saying that the Pair rule requires a Key followed by a Colon token at the beginning. After that, one of three things is required: a TrueValue token, whatever is specified by the ValueArray rule, or whatever is specified by the PairArray rule. This rule will handle the parsing of Pairs. Here are some examples of where this rule applies.</p>
<div class="code_box"><pre><code>AKeyName: 10
&lt;Key&gt; &lt;Colon&gt; &lt;Value&gt;

AKeyName: [1 2]
&lt;Key&gt; &lt;Colon&gt; ValueArray
</code></pre></div>
<p>While developing Valkor, the grammar was in constant flux. Some of the modifications made to the grammar added functionality. Other changes had nothing to do with functionality and everything to do with syntax. This was the grammar that came out at the end:</p>
<div class="code_box"><pre><code>Value = PairArray | ValueArray | &lt;TrueValue&gt;
PairArray = &lt;OpenBrace&gt; Pair* &lt;CloseBrace&gt;
ValueArray = &lt;OpenBracket&gt; (ValueList | ValueArrayList)? &lt;CloseBracket&gt;
Pair = &lt;Key&gt; (Value)
ValueList = Value (&lt;Comma&gt; Value)* &lt;Comma&gt;?
ValueArrayList = ValueArray (&lt;Comma&gt; ValueArray)* &lt;Comma&gt;?
</code></pre></div>
<p>There isn&apos;t so much to say about this grammar. Don&apos;t mistake that as a bad thing. It means it&apos;s in a state where I don&apos;t see any problems with it. This was not the case for the grammar that came just before it. It contained some strange rules that I am glad to be rid of.</p>
<div class="code_box"><pre><code>Root = Pair | PairArray
</code></pre></div>
<p>This was one of the rules in the last grammar. It was introduced pretty early on when I had the bad idea to allow the root Value to have a key string. There&apos;s not much to say since this has already been discussed, but the rule is a nice incarnation of the trouble I had in shifting my view from Pairs to Values. This rule was at the top of the grammar too. The biggest problem in my interface was staring directly at me from the top of my grammar.</p>
<p>If you looked closely at the latest grammar, you probably noticed the inclusion of commas. In the early versions, commas were not necessary for separating Values in a ValueArray. The reason they were included surprised me. It wasn&apos;t because they were needed to separate elements. Whitespace can take care of that. They were only added for the sake of readability. In particular, for single line ValueArrays. Consider the following example:</p>
<div class="code_box"><pre><code>:ArrayWithoutCommas: [1 2 3 4 5]

:ArrayWithCommas: [1, 2, 3, 4, 5]
</code></pre></div>
<p>Both of these can work, but the first one is uncanny because the values aren&apos;t clearly separated. Maybe the fact that commas are always used as array delimeters made this an issue for me, but the problem becomes more pronounced when using something more complex than single digit values.</p>
<div class="code_box"><pre><code>:Scale: [19.0446 0.425312 19.0446]
:Rotation: [0.766958 0.0543292 0.639127 -0.0184262]
:Translation: [0.967143 -3.55576 -2.28235]

:CommaScale: [19.0446, 0.425312, 19.0446]
:CommaRotation: [0.766958, 0.0543292, 0.639127, -0.0184262]
:CommaTranslation: [0.967143, -3.55576, -2.28235]
</code></pre></div>
<h1>Deserialization</h1>
<p>At this point, I had nearly made it full circle. Data could be written to file and that file could be read back into the Vlk::Value structure. The last step in completing the deserialization process is getting the data stored in the Vlk::Value back to where it started. When I arrived at this step, some complications arose that I did not at all expect. To fully explain, I need to provide some context.</p>
<p>Value makes extensive use of three operators: <code>()</code>, <code>[]</code>, and <code>=</code>. The type of operator used on a Value directly correlates to the Value&apos;s type. Using <code>()</code> means the Value&apos;s type is <code>PairArray</code>. Using <code>[]</code> means the Value&apos;s type is <code>ValueArray</code>. Using <code>=</code> means the Value&apos;s type is <code>TrueValue</code>. Of these three, the most awkward is the <code>()</code> operator because it doesn&apos;t represent something analogous to what it would usually be used for. This is not the case for the <code>[]</code> and <code>=</code> operators, because their function is extremely similar to the norm. <code>[]</code> indexes into arrays and <code>=</code> assigns a value. Fortunately, a bit of documentation can explain the purpose of the <code>()</code> operator.</p>
<p>These were and still are effective uses of operator overloading, but issues occured when accounting for deserialization. Early on, I attempted to have both serialization and deserialization happen through the Value structure, but this didn&apos;t end up happening. As explained earlier, <code>()</code> adds a Pair to a PairArray Value. Well, in my early version of deserialization, <code>()</code> had a const version that would find the Pair that had the given argument as a key. This is more easily explained with an example. </p>
<div class="code_box"><pre><code>Vlk::Pair root;
root.Read(<span class="hljs-string">&quot;filename.vlk&quot;</span>);
<span class="hljs-keyword">const</span> Vlk::Pair&amp; constRoot = root;
<span class="hljs-keyword">const</span> Vlk::Pair&amp; containedPair = constRoot(<span class="hljs-string">&quot;ContainedPair&quot;</span>);
<span class="hljs-keyword">const</span> Vlk::Pair&amp; otherContainedPair = root(<span class="hljs-string">&quot;OtherContainedPair&quot;</span>);
otherContainedPair = constRoot(<span class="hljs-string">&quot;OtherContainedPair&quot;</span>);
</code></pre></div>
<p>First, notice that we need to convert the root Pair into a const Pair on the third line. That&apos;s just a bit annoying. The big issue is the <code>constRoot(&quot;ContainedPair&quot;)</code> on the next line. If you think that should add a Pair to the PairArray contained in constRoot, I admire your intuition, but you are wrong. Because we are using the <code>()</code> operator on a const Pair, no Pair is created. Instead, if a Pair with the key <code>ContainedPair</code> exists in the root PairArray, that Pair will be returned. If it does not exist, there will be a crash. Now compare this to the line directly after it with the statement <code>root(&quot;OtherContainedPair&quot;)</code>. This does what I explained earlier. It creates a Pair within the root PairArray.</p>
<p>Despite having completely identical syntax and the same fundamental type, the functionality of the two lines are completely different. This does not exist in the current version of Valkor for obvious reasons, but holy shit, it was a smell I will remember for a long time. Despite the frustration that arose from this, I am glad I implemented it, because it is a perfect example of the dangers of operator overloading, which is something I had never encountered.</p>
<p>Not only did the overloading nonsense need handling, the fact that there would be a crash if the user attempted to access a nonexistent Value also needed addressing. There was no way to handle an error when the invalid access attempt was made. That&apos;s when Vlk::Explorers became a thing.</p>
<p>Instead of performing the deserialization purely through Vlk::Value, the Vlk::Explorer was added as a means to explore a Vlk::Value. Anytime the user attempts to access something that doesn&apos;t exist, an error is logged with details on exactly what access attempt was made and where within the Vlk::Value the attempt occured. As usual, this is easier explained by example.</p>
<div class="code_box"><pre><code>Vlk::Pair root;
root.Read(<span class="hljs-string">&quot;file.vlk&quot;</span>);
<span class="hljs-function">Vlk::Explorer <span class="hljs-title">rootEx</span><span class="hljs-params">(root)</span></span>;
Vlk::Explorer fourthString = rootEx(<span class="hljs-string">&quot;Container&quot;</span>)(<span class="hljs-string">&quot;Strings&quot;</span>)[<span class="hljs-number">4</span>];

<span class="hljs-comment">/*****
file.vlk
{
  :Container: {
    :Strings: [
      &quot;0&quot;,
      &quot;1&quot;,
      &quot;2&quot;,
      &quot;3&quot;
    ]
  }
}

The error that is printed to console.

Error|src/vlk/Explorer.cc(123)|Vlk::Explorer::operator []|
{}{Container}{Strings} did not contain Value at [4]
*****/</span>
</code></pre></div>
<p>Because the <code>Strings</code> ValueArray did not contain a fourth element, the Vlk::Explorer logged an error. That error specifies exactly where the access attempt was made, making it easier for the user to know where the problem might be within their code. In this case, the logged error says the access attempt was made within <code>{}{Container}{Strings}</code> where root represents our root pair. Since errors like this are expected, there also needs to be a way to detect that an error has occured in the deserialization code. The Vlk::Explorer provides a <code>Valid</code> function for just that reason.</p>
<div class="code_box"><pre><code><span class="hljs-keyword">if</span> (!fourthString.Valid())
{
  LogError(<span class="hljs-string">&quot;Fourth string not found.&quot;</span>);
  <span class="hljs-keyword">return</span>;
}
</code></pre></div>
<p>In the case of the example above, <code>fourthString</code> is not a valid explorer, hence the condition is satisfied and the function is exited. I believe it&apos;s necessary to have this kind of information and error handling because of how useful it can be. Just imagine having multiple thousands of lines in a vlk file and being expected to quickly diagnose errors like this without any information. It sounds like a train wreck. Futhermore, a user might want these errors if they expect them to occur for some reason. This is the case for any vlk files containing versioning information. It certainly feels quirky to have another structure for deserialization, but Vlk::Explorer handles the job while also addressing any errors that might occur. I would like a more consolidated interface, but the features provided by it are necessary.</p>
<h1>Concluding Thoughts</h1>
<p>This post is long overdue. The near final version of Valkor was completed months ago, but I kept putting this post to the side. For one, I went on a month and a half long trip, but before that I was too excited about saving and loading vlk files within Varkor to write anything. With Valkor, I was finally able to handle the whole serialization/deserialization process for assets, component types, and entire spaces. The result of that is the ability to load and save levels to file. The advantages of this are massive. Spaces no longer need to be created every time I test a feature that requires me to create game objects with certain components. Now I can just save a space to file and load it every time I test whatever it is I am working on. Testing graphics features will take advantage of this the most first, but other systems will be making use of it too. Physics is the most obvious one that comes to mind. What&apos;s even better than that is the ability to finally build something that isn&apos;t code and not lose the work when I close Varkor. Having that takes Varkor from being the toy it was months ago to being a tool that can actually be used to build something. It only took a year, but I am glad to have finally reached the top of this mountain that I have been hiking up. Now it&apos;s time to head into the next valley.</p>
<p>If you managed to reach here, I hope you enjoyed the read. I was writing this on and off over the course of the last two months while traveling and wrapped it up after returning. Creating something coherent during that stretched period of time was difficult. The scattered development of Valkor made it even harder. If anything, I hope the post is reminiscent of what developing the language was like.</p>
<p>As a parting gift, here is a gif showing the loading in action. The goal of everything discussed in the post was to make such a thing possible. Now I think it&apos;s finally time to start improving the look and variety of the things that can be loaded.</p>
<p class="image_box"><img src="space_loading.gif" alt="space loading" loading="lazy"></p></div>
  </div>


</body></html>